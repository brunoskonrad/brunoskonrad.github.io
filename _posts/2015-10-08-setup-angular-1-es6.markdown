---
layout: post
title:  "Setup: Angular 1.x com ES2015"
date:   2015-10-08 00:00:00
tags: angularjs es2015
author: Bruno Konrad
---
Nessa altura do campeonato a definiÃ§Ã£o da "nova versÃ£o" do Javascript jÃ¡ estÃ¡ entre aspas mesmo: nÃ£o Ã© novo. JÃ¡ esÃ¡ padronizada e temos a versÃ£o da ES2015 - antiga ES6 - definida. A dÃºvida que fica Ã© "como usar, hoje, em meu site ou app, os novos recursos que a linguagem me oferece?". Pois Ã©, os navegadores ainda estÃ£o implementando o novo padrÃ£o e vocÃª ainda nÃ£o pode tirar proveito de tudo ðŸ˜ž. E se eu te dizer que dÃ¡ pra, sim, usar isso hoje e em sua aplicaÃ§Ã£o Angular 1.x?

### Como fazemos isso?

Como vamos trabalhar com Javascript nÃ£o pode faltar: **node.js**! Se vocÃª ainda nÃ£o tem instalado na sua mÃ¡quina fica aqui a minha dica de ferramenta para instalaÃ§Ã£o: [nvm](https://github.com/creationix/nvm); se vocÃª for de Windows use o [nvmw](https://github.com/hakobera/nvmw).

Vamos comeÃ§ar!

#### Iniciando o projeto

{% highlight bash %}
npm init
{% endhighlight %}

O comando acima irÃ¡ criar o seu arquivo `package.json` que serÃ¡ usado para versionar as dependÃªncias do seu projeto. Nada mais de baixar o `angular.min.js` e colar numa pasta `lib`. Agora vocÃª vai fazer algo como:

{% highlight bash %}
npm i --save angular
{% endhighlight %}

Isso irÃ¡ criar um campo `dependencies` no seu *json* de configuraÃ§Ã£o no `package.json` e, nesse campo, estarÃ¡ definido o `angular` com uma versÃ£o especÃ­fica como uma das dependÃªncias.

A list de dependÃªncias para esse post Ã© esta, porÃ©m lembre-se de verificar se estÃ£o nas versÃµes mais atuais:

{% highlight javascript %}
"devDependencies": {
  "angular-mocks": "^1.4.7",
  "babel-core": "^5.8.25",
  "babel-loader": "^5.3.2",
  "html-loader": "^0.3.0",
  "jasmine-core": "^2.3.4",
  "karma": "^0.13.10",
  "karma-jasmine": "^0.3.6",
  "karma-phantomjs-launcher": "^0.2.1",
  "karma-webpack": "^1.7.0",
  "phantomjs": "^1.9.18",
  "webpack": "^1.12.2",
  "webpack-dev-server": "^1.12.1"
}
{% endhighlight %}

Adicione as `devDependencies` depois das suas `dependencies`, no seu `package.json`. ApÃ³s adicionÃ¡-las execute:

{% highlight bash %}
npm install
{% endhighlight %}

Espere o NPM fazer o trabalho de instalar as suas dependÃªncias. para mais informaÃ§Ãµes sobre a configuraÃ§Ã£o para esse post acesse o [`package.json`](https://github.com/brunoskonrad/angular-es2015/blob/master/package.json) do mesmo.

#### Configurando o build system

Enfim o ES2015 trouxe uma forma de separar mÃ³dulos em arquivos `.js`. Mas o nosso browser pode nÃ£o reconhecer isso ainda. Para nos auxiliar nesse trabalho iremos usar o [webpack](https://webpack.github.io/).

VocÃª pode instalÃ¡-lo globalmente e usar via terminal ou, como eu prefiro, [usando os `scripts` do seu `package.json`]({% post_url 2015-09-09-scripts-npm %}).

Se quiser instalar globalmente, execute a linha abaixo
{% highlight bash %}
npm i -g webpack
{% endhighlight %}

Crie, na raÃ­z do seu diretÃ³rio, um arquivo `webpack.config.js` que deverÃ¡ exportar um `object` de configuraÃ§Ã£o para o Webpack.

A configuraÃ§Ã£o do projeto de exemplo pode ser vista [aqui](https://github.com/brunoskonrad/angular-es2015/blob/master/webpack.config.js). Note que eu verifico se o ambiente estÃ¡ para teste ou nÃ£o. Caso nÃ£o seja de produÃ§Ã£o Ã© configurada a forma que sÃ£o exportados os arquivos, por exemplo:

{% highlight javascript %}
{
  // o contexto do cÃ³digo, no caso Ã© a pasta `src`
  context: __dirname + '/src',
  // o arquivo de entrada, no caso o `index.js`
  entry: './index',
  // aonde serÃ¡ enviado o arquivo de output
  output: {
    path: __dirname + '/build',
    filename: 'bundle.js'
  }
}
{% endhighlight %}

Se o ambiente for de teste, entÃ£o, Ã© importante definir a dependÃªncia `angular` como global, assim:

{% highlight javascript %}
{
  // Note que aqui deixo essas configuraÃ§Ãµes como objetos vazios
  entry: {},
  output: {},
  devtool: 'inline-source-map',
  // Aqui eu defino as dependÃªncias externas pois elas sÃ£o definidas pelo karma.
  // Explico mais sobre abaixo.
  externals: {
    'angular': 'angular'
  };
}
{% endhighlight %}

Por que definimos o `angular` como uma dependÃªncia externa? Porque o Karma define essas dependÃªncias de maneira global. Pode verificar [aqui](https://github.com/brunoskonrad/angular-es2015/blob/master/karma.conf.js) mas Ã© da seguinte forma:

{% highlight javascript %}
files: [
  // Aqui, nessa configuraÃ§Ã£o, importa o angular e o angular-mocks globalmente
  'node_modules/angular/angular.js',
  'node_modules/angular-mocks/angular-mocks.js',
  'src/index.js',
  'specs/**/*.spec.js'
]
{% endhighlight %}

### Como estÃ¡ organizado?

O cÃ³digo estÃ¡ organizado na seguinte estrutura:

{% highlight bash %}
|-- build
|   |-- templates
|   |-- index.html
|-- specs
|   |-- controllers
|   |-- directives
|   |-- services
|-- src
|   |-- controllers
|   |-- directives
|   |-- services
|   |-- index.js
|-- karma.conf.js
|-- package.json
|-- wepack.config.js
{% endhighlight %}

* `build`: fica o compilado do `src`, o `index.html` raiz da aplicaÃ§Ã£o e os templates `html` usados internamente. Importante notar que a referÃªncia para os templates Ã© como se estivessem no mesmo nÃ­vel, e.g: `templates/foo.html`;
* `specs`: testes da tua aplicaÃ§Ã£o. Ã‰ interessante seguir a mesma estrutura do diretÃ³rio de `src`. Os testes devem ter, apÃ³s o nome do arquivo a ser testado, o sufixo `.spec.js`. Mais [aqui](https://github.com/brunoskonrad/angular-es2015/tree/master/specs);
* `src`: onde serÃ£o escritos o cÃ³digo da aplicaÃ§Ã£o. A estrutura padrÃ£o Ã© possuir os *controllers*, as *directives* e os *services*. PorÃ©m pode-se adicionar o qeu for preciso, e.g `polyfill`. Na raiz desse diretÃ³rio fica a `index.js` que Ã© o ponto de entrada para a *compilaÃ§Ã£o* de ES2015 para ES5.
* `karma.conf.js`: arquivo de [configuraÃ§Ã£o](http://karma-runner.github.io/0.8/config/configuration-file.html) do [karma](http://karma-runner.github.io/0.13/index.html);
* `package.json`: arquivo de projeto node. Criado com `npm init`. [ConfiguraÃ§Ãµes](https://docs.npmjs.com/files/package.json) em geral podem ser feitas aqui.
* `webpack.config.js`: configuraÃ§Ã£o do webpack (mais sobre [aqui](http://webpack.github.io/docs/configuration.html)).

Lembrando que esse Ã© o ponto de partida! Pode e deve ser alterado para a sua necessidade.

Repare que, para cada diretÃ³rio dentro de `src`, foi criado um `alias` para facilitar a inclusÃ£o de arquivos de cada *pacote*, e.g:
{% highlight javascript %}
resolve: {
  alias: {
    controllers: __dirname + '/src/controllers',
    services: __dirname + '/src/services',
    directives: __dirname + '/src/directives'
  }
}
{% endhighlight %}

Tendo esses `alias` definidos vocÃª passa a importar os mÃ³dulos da seguinte forma:

{% highlight javascript %}
import HelloWorldCtrl from 'controllers/HelloWorldCtrl';

// Ao invÃ©s de

import HelloWorldCtrl from './contorllers/HelloWorldCtrl';
// ou
import HelloWorldCtrl from '../../contorllers/HelloWorldCtrl';
{% endhighlight %}

## Show me the code

Ok, depois de tudo isso (que Ã© bastante coisa) vamos ver como Ã© que Ã© o nosso cÃ³digo! Algumas coisas que vocÃª precisa ter em mente:
1. *controllers*, *services* e afins sÃ£o representados como classes Javascript;
1. As dependÃªncias sÃ£o passadas como argumentos na funÃ§Ã£o `constructor` de suas classes;
1. Passe as dependÃªncias para `this`, e.g `this.service = MyService`;

## Controllers

Um code snippet de como definir um *controller*:

{% highlight javascript %}
export default class HelloWorldCtrl {
  constructor($scope, Foo) {
    $scope.hello = 'world';
    $scope.foo = Foo.getFoo();
  }
}
{% endhighlight %}

No cÃ³digo acima definimos e exportamos como padrÃ£o a classe [`HelloWorldCtrl`](https://github.com/brunoskonrad/angular-es2015/blob/master/src/controllers/HelloWorldCtrl.js)

O uso de `$scope` pode ser uma dificuldade na sua codificaÃ§Ã£o. Pode-se optar usar o `this` para referÃªnciar os dados para o `two-way data-binding`.

Testes em angular possuem algumas configuraÃ§Ãµes para a injeÃ§Ã£o das dependÃªncias. Segue abaixo o teste para o `HelloWorldCtrl` (pode acessÃ¡-lo [aqui](https://github.com/brunoskonrad/angular-es2015/blob/master/specs/controllers/HelloWorldCtrl.spec.js))

{% highlight javascript %}
let subject;
let $controller;
let $rootScope;
let scope;
let Foo;

describe('HelloWorldCtrl', () => {
  // Definimos o mÃ³dulo que serÃ¡ carregado
  beforeEach(angular.mock.module('hello-world.controllers'));

  // Pegamos as referÃªncias para as dependÃªncias de nosso controller.
  // Note o `_` entre as dependÃªncias: isso Ã© um truque para conseguirmos
  // manter o mesmo nome localmente. e.g `let Foo = _Foo_`
  beforeEach(angular.mock.inject((_$controller_, _Foo_, _$rootScope_) => {
    $controller = _$controller_;
    $rootScope = _$rootScope_;
    Foo = _Foo_;
  }));

  // Antes de cada teste iremos iniciar um novo `scope`
  // e instanciar o controller que iremos testar usando o $controller,
  // injetando as dependÃªncias para o teste
  beforeEach(() => {
    scope = $rootScope.$new();
    subject = $controller('HelloWorldCtrl', {
      $scope: scope,
      Foo
    });
  });

  it('get the `hello` property as `world`', () => {
    expect(scope.hello).toBe('world');
  });

  it('access the `foo` property', () => {
    spyOn(Foo, 'getFoo').and.returnValue('foo');

    scope.$digest();

    expect(scope.foo).toBe('foo');
  });
});
{% endhighlight %}

## Services

Services sÃ£o `singletone`, entÃ£o os mÃ©todos da classe sÃ£o as funÃ§Ãµes disponÃ­veis no seu service. Segue abaixo um snippet:

{% highlight javascript %}
export default class Foo {
  constructor() { }

  getFoo() {
    return 'foo';
  }
}
{% endhighlight %}

Esse *service* `Foo` Ã© uma dependÃªncia do *controller* `HelloWorldCtrl` declarado acima.

Um exemplo de como testar o seu *service*:

{% highlight javascript %}
let subject;

describe('Foo', () => {
  beforeEach(angular.mock.module('hello-world.services'));

  beforeEach(angular.mock.inject((Foo) => {
    subject = Foo;
  }));

  it('gets the foo', () => {
    expect(subject.getFoo()).toBe('foo');
  });
});
{% endhighlight %}

## Directives

Declarar uma *directive* continua sendo uma funÃ§Ã£o. Seguindo as [liÃ§Ãµes aprendidas no Paypal](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef), Ã© interessante que as *directives* tenham seus *controllers* e que se construam aplicaÃ§Ãµes Angular orientadas pelas *directives*. Segue-se um snippet de *directive* e seu *controller*:

{% highlight javascript %}
export function helloWorld() {
  return {
    restrict: 'E',
    scope: {
      who: '@'
    },
    controller: 'HelloWorldDirectiveCtrl',
    templateUrl: 'templates/hello-world.html'
  }
}

export class HelloWorldDirectiveCtrl {
  constructor($scope) {
    this.scope = $scope;
    $scope.who = $scope.who || 'world';
    $scope.helloWorldClick = this.helloWorldClick.bind(this);
  }

  helloWorldClick() {
    alert(`Hello ${this.scope.who}`);
  }
}
{% endhighlight %}

Definimos e exportamos ambos em um mesmo [arquivo](https://github.com/brunoskonrad/angular-es2015/blob/master/src/directives/HelloWorld.js), afinal um pertence ao outro!

Para testar fazemo-os separadamente. O motivo Ã© que, para *controller*, *services* e as *directives* bem como os *controllers* das directives possuÃ­mos `angular.module` diferentes. Veja no [`index.js`](https://github.com/brunoskonrad/angular-es2015/blob/master/src/index.js) para visualizar essa separaÃ§Ã£o.

* Testes para a *directive*: https://github.com/brunoskonrad/angular-es2015/blob/master/specs/directives/HelloWorld/HelloWorld.spec.js;
* Testes para o *controller* da *directive*: https://github.com/brunoskonrad/angular-es2015/blob/master/specs/directives/HelloWorld/HelloWorldCtrl.spec.js

<hr />

## Bibliografia

1. O cÃ³digo base pode ser acessado em: [https://github.com/brunoskonrad/angular-es2015](https://github.com/brunoskonrad/angular-es2015)
1. Leitura recomendada sobre boas prÃ¡ticas com angular: [Sane, scalable Angular apps are tricky, but not impossible. Lessons learned from PayPal Checkout.](https://medium.com/@bluepnume/sane-scalable-angular-apps-are-tricky-but-not-impossible-lessons-learned-from-paypal-checkout-c5320558d4ef)
1. ReferÃªncia em inglÃªs de angular 1.x com ES6 e webpack: [http://angular-tips.com/blog/2015/06/using-angular-1-dot-x-with-es6-and-webpack/](http://angular-tips.com/blog/2015/06/using-angular-1-dot-x-with-es6-and-webpack/)
1. ReferÃªncias para testes:
* [http://angular-tips.com/blog/2015/06/using-angular-1-dot-x-with-es6-and-webpack/](http://www.sitepoint.com/mocking-dependencies-angularjs-tests/);
* [http://www.sitepoint.com/unit-testing-angularjs-services-controllers-providers/](http://www.sitepoint.com/unit-testing-angularjs-services-controllers-providers/);
* [http://andyshora.com/unit-testing-best-practices-angularjs.html](http://andyshora.com/unit-testing-best-practices-angularjs.html);
